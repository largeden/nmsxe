<?php
    class pChartItem extends pChart {

        var $nmsValueCount = NULL;
        var $nmsWidthValueSize = NULL;
        var $nmsCountDelay = NULL;
        var $nmsCountMinus = NULL;
        var $nmsLabelLeft = NULL;
        var $nmsLabelTop = NULL;
        var $nmsMini = NULL;

        var $dG_line = 0;
        var $dG_line_uner = 25;
        var $dS_Y = 0;
        var $LabelDelayName = 70;
        var $R_ShadowFactor = 0;
        var $G_ShadowFactor = 0;
        var $B_ShadowFactor = 0;

        /* Set the graph area location */
        function setGraphArea($X1=null,$Y1=null,$X2=null,$Y2=null) {
            if($X1 != null) $this->GArea_X1 = $X1;
            if($Y1 != null) $this->GArea_Y1 = $Y1;
            if($X2 != null) $this->GArea_X2 = $X2;
            if($Y2 != null) $this->GArea_Y2 = $Y2;
        }

        /* Convert to metric system */
        function ToMetric($value, $round = 3, $byte = 1000) {
            // 요청값이 숫자가 아니면 그대로 리턴
            if(!preg_match("/^\.?[0-9]+([\.0-9]+)?[0-9]$/", $value)) return $value;

            $Go = floor($value/($byte*$byte*$byte));
            $Mo = floor(($value - $Go*($byte*$byte*$byte))/($byte*$byte));
            $Ko = floor(($value - $Go*($byte*$byte*$byte) - $Mo*($byte*$byte))/$byte);
            $o  = floor($value - $Go*($byte*$byte*$byte) - $Mo*($byte*$byte) - $Ko*$byte);

            if($Go != 0) return round(($Go.".".$Mo),$round)."G";
            if($Mo != 0) return round(($Mo.".".$Ko),$round)."M";
            if($Ko != 0) return round(($Ko.".".$o),$round)."K";

            if($o == 0) return round($value,$round);
            else return $o;
        }

        /* Convert TS to a date format string */
        function ToDate($Value) {
            if(!$Value) return;
            return(date($this->DateFormat,strtotime($Value)));
        }

        /* Prepare the graph area */
        function drawGraphArea($R,$G,$B,$Stripe=FALSE) {
            $this->drawFilledRectangle($this->GArea_X1,$this->GArea_Y1,$this->GArea_X2,$this->GArea_Y2,$R,$G,$B,FALSE);
            $this->drawRectangle($this->GArea_X1,$this->GArea_Y1,$this->GArea_X2,$this->GArea_Y2,$R-20,$G-20,$B-20);

            if ( $Stripe ) {
                $R2 = $R-15; if ( $R2 < 0 ) { $R2 = 0; }
                $G2 = $R-15; if ( $G2 < 0 ) { $G2 = 0; }
                $B2 = $R-15; if ( $B2 < 0 ) { $B2 = 0; }

                $LineColor =$this->AllocateColor($this->Picture,$R2,$G2,$B2);
                $SkewWidth = $this->GArea_Y2-$this->GArea_Y1-1;

                for($i=$this->GArea_X1-$SkewWidth;$i<=$this->GArea_X2;$i=$i+4) {
                    $X1 = $i;
                    $Y1 = $this->GArea_Y2;
                    $X2 = $i+$SkewWidth;
                    $Y2 = $this->GArea_Y1;

                    if($X1 < $this->GArea_X1) { $X1 = $this->GArea_X1; $Y1 = $this->GArea_Y1 + $X2 - $this->GArea_X1 + 1; }

                    if($X2 >= $this->GArea_X2) { $Y2 = $this->GArea_Y1 + $X2 - $this->GArea_X2 +1; $X2 = $this->GArea_X2 - 1; }

                    imageline($this->Picture,$X1,$Y1,$X2,$Y2+1,$LineColor);
                }
            }
        }

        /* This function draw a filled cubic curve */
        function drawFilledCubicCurve($Data,$DataDescription,$Accuracy=.1,$Alpha=100,$AroundZero=FALSE) {
            /* Validate the Data and DataDescription array */
            $this->validateDataDescription("drawFilledCubicCurve",$DataDescription);
            $this->validateData("drawFilledCubicCurve",$Data);

            $LayerWidth  = $this->GArea_X2-$this->GArea_X1;
            $LayerHeight = $this->GArea_Y2-$this->GArea_Y1;
            $YZero = $LayerHeight - ((0-$this->VMin) * $this->DivisionRatio);
            if($YZero>$LayerHeight) $YZero = $LayerHeight;

            $GraphID = 0;
            foreach($DataDescription["Values"] as $Key2 => $ColName) {
            $XIn = ""; $Yin = ""; $Yt = ""; $U = "";
            $XIn[0] = 0; $YIn[0] = 0;

            $ID = 0;
            foreach($DataDescription["Description"] as $keyI => $ValueI) {
                if($keyI == $ColName) { $ColorID = $ID; }; $ID++;
            }

            $Index = 1;
            $XLast = -1; $Missing = "";
            foreach($Data as $Key => $Values) {
                $Value = $Data[$Key][$ColName];
                $XIn[$Index] = $Index;
                $YIn[$Index] = $Value;
                if(!is_numeric($Value)) $Missing[$Index] = TRUE;
                $Index++;
            }
            $Index--;

            $Yt[0] = 0;
            $Yt[1] = 0;
            $U[1] = 0;
            for($i=2;$i<=$Index-1;$i++) {
                $Sig = ($XIn[$i] - $XIn[$i-1]) / ($XIn[$i+1] - $XIn[$i-1]);
                $p = $Sig * $Yt[$i-1] + 2;
                $Yt[$i] = ($Sig - 1) / $p;
                $U[$i] = ($YIn[$i+1] - $YIn[$i]) / ($XIn[$i+1] - $XIn[$i]) - ($YIn[$i] - $YIn[$i-1]) / ($XIn[$i] - $XIn[$i-1]);
                $U[$i] = (6 * $U[$i] / ($XIn[$i+1] - $XIn[$i-1]) - $Sig * $U[$i-1]) / $p;
            }

            $qn = 0;
            $un = 0;
            $Yt[$Index] = ($un - $qn * $U[$Index-1]) / ($qn * $Yt[$Index-1] + 1);

            for($k=$Index-1;$k>=1;$k--)
            $Yt[$k] = $Yt[$k] * $Yt[$k+1] + $U[$k];

            $Points = "";
            $Points[] = $this->GAreaXOffset;
            $Points[] = $LayerHeight;

            $this->Layers[0] = imagecreatetruecolor($LayerWidth,$LayerHeight);
            $C_White = $this->AllocateColor($this->Layers[0],255,255,255);
            imagefilledrectangle($this->Layers[0],0,0,$LayerWidth,$LayerHeight,$C_White);
            imagecolortransparent($this->Layers[0],$C_White);

            $YLast = NULL;
            $XPos = $this->GAreaXOffset; $PointsCount = 2;
            for($X=1;$X<=$Index;$X=$X+$Accuracy) {
                $klo = 1;
                $khi = $Index;
                $k = $khi - $klo;
                while($k > 1) {
                    $k = $khi - $klo;
                    if($XIn[$k] >= $X) $khi = $k;
                    else $klo = $k;
                }

                $klo = $khi - 1;

                $h = $XIn[$khi] - $XIn[$klo];
                $a = ($XIn[$khi] - $X) / $h;
                $b = ($X - $XIn[$klo]) / $h;
                $Value = $a * $YIn[$klo] + $b * $YIn[$khi] + (($a*$a*$a - $a) * $Yt[$klo] + ($b*$b*$b - $b) * $Yt[$khi]) * ($h*$h) / 6;

                $YPos = $LayerHeight - (($Value-$this->VMin) * $this->DivisionRatio);

                if($YLast != NULL && $AroundZero && !isset($Missing[floor($X)]) && !isset($Missing[floor($X+1)])) {
                    $aPoints = "";
                    $aPoints[] = $XLast;
                    $aPoints[] = $YLast;
                    $aPoints[] = $XPos;
                    $aPoints[] = $YPos;
                    $aPoints[] = $XPos;
                    $aPoints[] = $YZero;
                    $aPoints[] = $XLast;
                    $aPoints[] = $YZero;

                    $C_Graph =$this->AllocateColor($this->Layers[0],$this->Palette[$ColorID]["R"],$this->Palette[$ColorID]["G"],$this->Palette[$ColorID]["B"]);
                    imagefilledpolygon($this->Layers[0],$aPoints,4,$C_Graph);
                }

                if(!isset($Missing[floor($X)]) || $YLast == NULL) {
                    $PointsCount++;
                    $Points[] = $XPos;
                    $Points[] = $YPos;
                 } else { $PointsCount++; $Points[] = $XLast; $Points[] = $LayerHeight; }

                $YLast = $YPos; $XLast = $XPos;
                $XPos = $XPos + $this->DivisionWidth * $Accuracy;
            }

            // Add potentialy missing values
            $XPos = $XPos - $this->DivisionWidth * $Accuracy;
            if($XPos < ($LayerWidth-$this->GAreaXOffset)) {
                $YPos = $LayerHeight - (($YIn[$Index]-$this->VMin) * $this->DivisionRatio);

                if($YLast != NULL && $AroundZero) {
                    $aPoints = "";
                    $aPoints[] = $XLast;
                    $aPoints[] = $YLast;
                    $aPoints[] = $LayerWidth-$this->GAreaXOffset;
                    $aPoints[] = $YPos;
                    $aPoints[] = $LayerWidth-$this->GAreaXOffset;
                    $aPoints[] = $YZero;
                    $aPoints[] = $XLast;
                    $aPoints[] = $YZero;

                    $C_Graph = $this->AllocateColor($this->Layers[0],$this->Palette[$ColorID]["R"],$this->Palette[$ColorID]["G"],$this->Palette[$ColorID]["B"]);
                    imagefilledpolygon($this->Layers[0],$aPoints,4,$C_Graph);
                }

                if($YIn[$klo] != "" && $YIn[$khi] != "" || $YLast == NULL) {
                    $PointsCount++;
                    $Points[] = $LayerWidth-$this->GAreaXOffset;
                    $Points[] = $YPos;
                }
            }

            $Points[] = $LayerWidth-$this->GAreaXOffset;
            $Points[] = $LayerHeight;

            if(!$AroundZero) {
                $C_Graph =$this->AllocateColor($this->Layers[0],$this->Palette[$ColorID]["R"],$this->Palette[$ColorID]["G"],$this->Palette[$ColorID]["B"]);
                imagefilledpolygon($this->Layers[0],$Points,$PointsCount,$C_Graph);
            }

            imagecopymerge($this->Picture,$this->Layers[0],$this->GArea_X1,$this->GArea_Y1,0,0,$LayerWidth,$LayerHeight,$Alpha);
            imagedestroy($this->Layers[0]);

            $this->drawLineGraph($Data,$DataDescription,$ColName);

            $GraphID++;
            }
        }

        /* This function create a rectangle with antialias */
        function drawRectangle($X1,$Y1,$X2,$Y2,$R,$G,$B) {
            if($R < 0) { $R = 0; } if($R > 255) { $R = 255; }
            if($G < 0) { $G = 0; } if($G > 255) { $G = 255; }
            if($B < 0) { $B = 0; } if($B > 255) { $B = 255; }

            $C_Rectangle = $this->AllocateColor($this->Picture,$R,$G,$B);

            $X1=$X1-.1;$Y1=$Y1-.1;
            $X2=$X2+.1;$Y2=$Y2+.1;
            $this->drawLine($X1,$Y1,$X2,$Y1,$R,$G,$B);
            $this->drawLine($X2,$Y1,$X2,$Y2,$R,$G,$B);
            $this->drawLine($X2,$Y2,$X1,$Y2,$R,$G,$B);
            $this->drawLine($X1,$Y2,$X1,$Y1,$R,$G,$B);
        }

        /* Compute and draw the scale */
        function drawScale($Data,$DataDescription,$ScaleMode,$R,$G,$B,$DrawTicks=TRUE,$Angle=0,$Decimals=1,$WithMargin=FALSE,$SkipLabels=1) {
            /* Validate the Data and DataDescription array */
            $this->validateData("drawScale",$Data);

            $C_TextColor=$this->AllocateColor($this->Picture,$R,$G,$B);

            if($this->VMin == NULL && $this->VMax == NULL) {
                if(isset($DataDescription["Values"][0])) {
                    $this->VMin = $Data[0][$DataDescription["Values"][0]];
                    $this->VMax = $Data[0][$DataDescription["Values"][0]];
                } else {
                    $this->VMin = 2147483647;
                    $this->VMax = -2147483647;
                }
                /* Compute Min and Max values */
                if($ScaleMode == SCALE_NORMAL || $ScaleMode == SCALE_START0) {
                     if($ScaleMode == SCALE_START0) $this->VMin = 0;

                    foreach($Data as $Key=>$Values) {
                        foreach($DataDescription["Values"] as $Key2=>$ColName) {
                            if(isset($Data[$Key][$ColName])) {
                                $Value = $Data[$Key][$ColName];

                                if(is_numeric($Value)) {
                                    if($this->VMax < $Value) $this->VMax = $Value;
                                    if($this->VMin > $Value) $this->VMin = $Value;
                                }
                            }
                        }
                    }

                $Value = $this->VMax;
                $Value = round($Value*pow(10,$Decimals))/pow(10,$Decimals);

                if($DataDescription["Format"]["Y"] == "number") $Value = $Value.$DataDescription["Unit"]["Y"];
                if($DataDescription["Format"]["Y"] == "time") $Value = $this->ToTime($Value);
                if($DataDescription["Format"]["Y"] == "date") $Value = $this->ToDate($Value);
                if($DataDescription["Format"]["Y"] == "metric") $Value = $this->ToMetric($Value,1);
                if($DataDescription["Format"]["Y"] == "kbyte") $Value = $this->ToMetric($Value*1024,1,1024);
                if($DataDescription["Format"]["Y"] == "mbyte") $Value = $this->ToMetric($Value*1024*1024,1,1024);
                if($DataDescription["Format"]["Y"] == "gbyte") $Value = $this->ToMetric($Value*1024*1024*1024,1,1024);
                if($DataDescription["Format"]["Y"] == "currency") $Value = $this->ToCurrency($Value);

                $Position = imageftbbox($this->FontSize,0,$this->FontName,$Value);
                $TextWidth = $Position[2]-$Position[0];
                $TextHeight = $Position[5]-$Position[5]-$Position[5];

                if(!$this->nmsMini) $this->setGraphArea($this->GArea_X1+$TextWidth+20,$this->GArea_Y1+10,null,$this->GArea_Y2-10);

                } elseif($ScaleMode == SCALE_ADDALL || $ScaleMode == SCALE_ADDALLSTART0) {
                    /* Experimental */
                    if($ScaleMode == SCALE_ADDALLSTART0) $this->VMin = 0;

                    foreach($Data as $Key=>$Values) {
                        $Sum = 0;
                        foreach($DataDescription["Values"] as $Key2=>$ColName) {
                            if(isset($Data[$Key][$ColName])) {
                                $Value = $Data[$Key][$ColName];
                                if(is_numeric($Value)) $Sum += $Value;
                            }
                        }

                        if($this->VMax < $Sum) $this->VMax = $Sum;
                        if($this->VMin > $Sum) $this->VMin = $Sum;
                    }
                }

                if($this->VMax > preg_replace('/\.[0-9]+/','',$this->VMax)) $this->VMax = preg_replace('/\.[0-9]+/','',$this->VMax)+1;

                /* If all values are the same */
                if($this->VMax == $this->VMin) {
                    if($this->VMax >= 0) $this->VMax++;
                    else $this->VMin--;
                }

                $DataRange = $this->VMax - $this->VMin;
                if($DataRange == 0) $DataRange = .1;

                /* Compute automatic scaling */
                $ScaleOk = FALSE;
                $Factor = 1;
                $MinDivHeight = 25;
                $MaxDivs = ($this->GArea_Y2-$this->GArea_Y1)/$MinDivHeight;

                if($this->VMin == 0 && $this->VMax == 0) {
                    $this->VMin = 0;
                    $this->VMax = 2;
                    $Scale = 1;
                    $Divisions = 2;
                } elseif($MaxDivs > 1) {

                    while(!$ScaleOk) {
                        $Scale1 = ($this->VMax-$this->VMin)/$Factor;
                        $Scale2 = ($this->VMax-$this->VMin)/$Factor/2;
                        $Scale4 = ($this->VMax-$this->VMin)/$Factor/4;

                        if($Scale1 > 1 && $Scale1 <= $MaxDivs && !$ScaleOk) { $ScaleOk = TRUE; $Divisions = floor($Scale1); $Scale = 1;}
                        if($Scale2 > 1 && $Scale2 <= $MaxDivs && !$ScaleOk) { $ScaleOk = TRUE; $Divisions = floor($Scale2); $Scale = 2;}
                        if(!$ScaleOk) {
                            if($Scale2 > 1) $Factor = $Factor*10;
                            if($Scale2 < 1) $Factor = $Factor/10;
                        }
                    }

                    if(floor($this->VMax/$Scale/$Factor) != $this->VMax/$Scale/$Factor) {
                        $GridID = floor($this->VMax/$Scale/$Factor)+1;
                        $this->VMax = $GridID*$Scale*$Factor;
                        $Divisions++;
                    }

                    if(floor($this->VMin/$Scale/$Factor) != $this->VMin/$Scale/$Factor) {
                        $GridID = floor($this->VMin/$Scale/$Factor);
                        $this->VMin = $GridID*$Scale*$Factor;
                        $Divisions++;
                    }
                } else $Scale = 1; /* Can occurs for small graphs */

                if(!isset($Divisions)) $Divisions = 2;
                if($Scale==1 && $Divisions%2==1) $Divisions--;
            } else $Divisions = $this->Divisions;

            $this->DivisionCount = $Divisions;
            $DataRange = $this->VMax - $this->VMin;

            if($DataRange==0) $DataRange = .1;

            $this->DivisionHeight = ($this->GArea_Y2-$this->GArea_Y1)/$Divisions;
            $this->DivisionRatio = ($this->GArea_Y2-$this->GArea_Y1)/$DataRange;

            $this->GAreaXOffset = 0;

            if(count($Data) > 1) {
                if($WithMargin == FALSE) $this->DivisionWidth = ($this->GArea_X2-$this->GArea_X1+$TextWidth)/(count($Data)-1);
                else {
                    $this->DivisionWidth = ($this->GArea_X2-$this->GArea_X1)/(count($Data));
                    $this->GAreaXOffset  = $this->DivisionWidth/2;
                }
            } else {
                $this->DivisionWidth = $this->GArea_X2-$this->GArea_X1;
                $this->GAreaXOffset  = $this->DivisionWidth/2;
            }

            $this->DataCount = count($Data);

            if($DrawTicks == FALSE) return(0);

            $YPos = $this->GArea_Y2;
            $XMin = NULL;

            for($i=1;$i<=$Divisions+1;$i++) {
                $Value = $this->VMin+($i-1)*(($this->VMax-$this->VMin)/$Divisions);
                $Value = round($Value*pow(10,$Decimals))/pow(10,$Decimals);

                if($DataDescription["Format"]["Y"] == "number") $Value = $Value.$DataDescription["Unit"]["Y"];
                if($DataDescription["Format"]["Y"] == "time") $Value = $this->ToTime($Value);
                if($DataDescription["Format"]["Y"] == "date") $Value = $this->ToDate($Value);
                if($DataDescription["Format"]["Y"] == "metric") $Value = $this->ToMetric($Value,1);
                if($DataDescription["Format"]["Y"] == "kbyte") $Value = $this->ToMetric($Value*1024,1,1024);
                if($DataDescription["Format"]["Y"] == "mbyte") $Value = $this->ToMetric($Value*1024*1024,1,1024);
                if($DataDescription["Format"]["Y"] == "gbyte") $Value = $this->ToMetric($Value*1024*1024*1024,1,1024);
                if($DataDescription["Format"]["Y"] == "currency") $Value = $this->ToCurrency($Value);

                $Position = imageftbbox($this->FontSize,0,$this->FontName,$Value);
                $TextWidth = $Position[2]-$Position[0];
                $TextHeight = $Position[5]-$Position[5]-$Position[5];

                if($this->nmsWidthValueSize < $TextWidth) $this->nmsWidthValueSize = $TextWidth;

                //$this->drawFilledRoundedRectangle($this->GArea_X1-13-$TextWidth,$YPos-($this->FontSize/2)-3,$TextWidth+10,$this->FontSize+7,7,0,0,0,50);
                //imagettftext($this->Picture,$this->FontSize,0,$this->GArea_X1-10-$TextWidth,$YPos+($this->FontSize/2),$C_TextColor,$this->FontName,$Value);
                if($XMin > $this->GArea_X1-10-$TextWidth || $XMin == NULL) $XMin = $this->GArea_X1-10-$TextWidth;

                $YPos = $YPos - $this->DivisionHeight;
            }

            /* Horizontal Axis */
            $XPos = $this->GArea_X1+$this->GAreaXOffset;
            $ID = 1;
            $YMax = NULL;
            $YPos = $this->GArea_Y2+25;
            $S_TextColor=$this->AllocateColor($this->Picture,40,40,40);

            foreach($Data as $Key=>$Values) {
                if($ID%$SkipLabels == 0) {
                    //$this->drawLine(floor($XPos),floor($YPos),floor($XPos),floor($YPos)+5,$R,$G,$B);
                    $Value = $Data[$Key][$DataDescription["Position"]];
                    if($DataDescription["Format"]["X"] == "number") $Value = $Value.$DataDescription["Unit"]["X"];
                    if($DataDescription["Format"]["X"] == "time") $Value = $this->ToTime($Value);
                    if($DataDescription["Format"]["X"] == "date") $Value = $this->ToDate($Value);
                    if($DataDescription["Format"]["X"] == "metric") $Value = $this->ToMetric($Value,1);
                    if($DataDescription["Format"]["X"] == "kbyte") $Value = $this->ToMetric($Value*1024,1,1024);
                    if($DataDescription["Format"]["X"] == "mbyte") $Value = $this->ToMetric($Value*1024*1024,1,1024);
                    if($DataDescription["Format"]["X"] == "gbyte") $Value = $this->ToMetric($Value*1024*1024*1024,1,1024);
                    if($DataDescription["Format"]["X"] == "currency") $Value = $this->ToCurrency($Value);

                    $Position = imageftbbox($this->FontSize,$Angle,$this->FontName,$Value);
                    $TextWidth = abs($Position[2])+abs($Position[0]);
                    $TextHeight = abs($Position[1])+abs($Position[3]);

                    if($Angle == 0) {
                        //$YPos = $this->GArea_Y2+18;
                        imagettftext($this->Picture,$this->FontSize,$Angle,floor($XPos)-floor($TextWidth/2),floor($YPos),$C_TextColor,$this->FontName,$Value);
                    } else {
                        $YPos = $this->GArea_Y2+10+$TextHeight;
                        if($Angle <= 90) imagettftext($this->Picture,$this->FontSize,$Angle,floor($XPos)-$TextWidth+5,$YPos,$C_TextColor,$this->FontName,$Value);
                        else imagettftext($this->Picture,$this->FontSize,$Angle,floor($XPos)+$TextWidth+5,$YPos,$C_TextColor,$this->FontName,$Value);
                    }

                    if($YMax<$YPos || $YMax==NULL) $YMax = $YPos;
                }

                $XPos = $XPos + $this->DivisionWidth;
                $ID++;
            }

            $this->nmsValueCount = $ID;

            /* Write the X Axis caption if set */
            if(isset($DataDescription["Axis"]["X"])) {
                $Position = imageftbbox($this->FontSize,90,$this->FontName,$DataDescription["Axis"]["X"]);
                $TextWidth = abs($Position[2])+abs($Position[0]);
                $TextLeft = (($this->GArea_X2-$this->GArea_X1)/2)+$this->GArea_X1+($TextWidth/2);
                imagettftext($this->Picture,$this->FontSize,0,$TextLeft,$YMax+$this->FontSize+5,$C_TextColor,$this->FontName,$DataDescription["Axis"]["X"]);
            }
        }

        /* Compute and draw the scale */
        function drawScale2($Data,$DataDescription,$ScaleMode,$R,$G,$B,$DrawTicks=TRUE,$Angle=0,$Decimals=1,$WithMargin=FALSE,$SkipLabels=1) {

            $this->VMin = null;
            $this->VMax = null;
            $this->setGraphArea($this->GArea_X1+$this->nmsWidthValueSize+20,$this->GArea_Y1+10,null,$this->GArea_Y2-10);

            /* Validate the Data and DataDescription array */
            $this->validateData("drawScale",$Data);
            $C_TextColor=$this->AllocateColor($this->Picture,$R,$G,$B);

            if($this->VMin == NULL && $this->VMax == NULL) {
                if(isset($DataDescription["Values"][0])) {
                    $this->VMin = $Data[0][$DataDescription["Values"][0]];
                    $this->VMax = $Data[0][$DataDescription["Values"][0]];
                } else {
                    $this->VMin = 2147483647;
                    $this->VMax = -2147483647;
                }

                /* Compute Min and Max values */
                if($ScaleMode == SCALE_NORMAL || $ScaleMode == SCALE_START0) {
                    if($ScaleMode == SCALE_START0) $this->VMin = 0;

                    foreach($Data as $Key=>$Values) {
                        foreach($DataDescription["Values"] as $Key2=>$ColName) {
                            if(isset($Data[$Key][$ColName])) {
                                $Value = $Data[$Key][$ColName];

                                if(is_numeric($Value)) {
                                    if($this->VMax < $Value) $this->VMax = $Value;
                                    if($this->VMin > $Value) $this->VMin = $Value;
                                }
                            }
                        }
                    }
                } elseif($ScaleMode == SCALE_ADDALL || $ScaleMode == SCALE_ADDALLSTART0) { /* Experimental */
                    if($ScaleMode == SCALE_ADDALLSTART0 ) $this->VMin = 0;

                    foreach($Data as $Key => $Values) {
                        $Sum = 0;
                        foreach($DataDescription["Values"] as $Key2=>$ColName) {
                            if(isset($Data[$Key][$ColName])) {
                                $Value = $Data[$Key][$ColName];
                                if(is_numeric($Value)) $Sum += $Value;
                            }
                        }
                        if($this->VMax < $Sum) $this->VMax = $Sum;
                        if($this->VMin > $Sum) $this->VMin = $Sum;
                    }
                }

                if($this->VMax > preg_replace('/\.[0-9]+/','',$this->VMax)) $this->VMax = preg_replace('/\.[0-9]+/','',$this->VMax)+1;

                /* If all values are the same */
                if($this->VMax == $this->VMin) {
                    if($this->VMax >= 0) $this->VMax++;
                    else $this->VMin--;
                }

                $DataRange = $this->VMax - $this->VMin;
                if($DataRange == 0) $DataRange = .1;

                /* Compute automatic scaling */
                $ScaleOk = FALSE;
                $Factor = 1;
                $MinDivHeight = 25;
                $MaxDivs = ($this->GArea_Y2-$this->GArea_Y1)/$MinDivHeight;

                if ( $this->VMin == 0 && $this->VMax == 0 ) {
                    $this->VMin = 0;
                    $this->VMax = 2;
                    $Scale = 1;
                    $Divisions = 2;
                } elseif($MaxDivs > 1) {

                    while(!$ScaleOk) {
                        $Scale1 = ($this->VMax-$this->VMin)/$Factor;
                        $Scale2 = ($this->VMax-$this->VMin)/$Factor/2;
                        $Scale4 = ($this->VMax-$this->VMin)/$Factor/4;

                        if($Scale1 > 1 && $Scale1 <= $MaxDivs && !$ScaleOk) { $ScaleOk = TRUE; $Divisions = floor($Scale1); $Scale = 1; }
                        if($Scale2 > 1 && $Scale2 <= $MaxDivs && !$ScaleOk) { $ScaleOk = TRUE; $Divisions = floor($Scale2); $Scale = 2; }
                        if(!$ScaleOk) {
                            if($Scale2 > 1) $Factor = $Factor*10;
                            if($Scale2 < 1) $Factor = $Factor/10;
                        }
                    }

                    if(floor($this->VMax/$Scale/$Factor) != $this->VMax/$Scale/$Factor) {
                        $GridID = floor($this->VMax/$Scale/$Factor)+1;
                        $this->VMax = $GridID*$Scale*$Factor;
                        $Divisions++;
                    }

                    if(floor($this->VMin/$Scale/$Factor) != $this->VMin/$Scale/$Factor) {
                        $GridID = floor( $this->VMin/$Scale/$Factor);
                        $this->VMin = $GridID*$Scale*$Factor;
                        $Divisions++;
                    }
                } else $Scale = 1; /* Can occurs for small graphs */

                if(!isset($Divisions)) $Divisions = 2;
                if($Scale==1 && $Divisions%2==1) $Divisions--;
            } else $Divisions = $this->Divisions;

            $this->DivisionCount = $Divisions;
             $DataRange = $this->VMax - $this->VMin;
            if($DataRange == 0) $DataRange = .1;

            $this->DivisionHeight = ($this->GArea_Y2-$this->GArea_Y1)/$Divisions;
            $this->DivisionRatio = ($this->GArea_Y2-$this->GArea_Y1)/$DataRange;

            $this->GAreaXOffset = 0;

            if(count($Data) > 1) {
                if($WithMargin == FALSE) $this->DivisionWidth = ($this->GArea_X2-$this->GArea_X1+$TextWidth)/(count($Data)-1);
                else {
                    $this->DivisionWidth = ($this->GArea_X2-$this->GArea_X1)/(count($Data));
                    $this->GAreaXOffset = $this->DivisionWidth/2;
                }
            } else {
                $this->DivisionWidth = $this->GArea_X2-$this->GArea_X1;
                $this->GAreaXOffset  = $this->DivisionWidth/2;
            }

            $this->DataCount = count($Data);

            if($DrawTicks == FALSE) return(0);

            $YPos = $this->GArea_Y2;
            $XMin = NULL;

            for($i=1;$i<=$Divisions+1;$i++) {
                $Value = $this->VMin+($i-1)*(($this->VMax-$this->VMin)/$Divisions);
                $Value = round($Value*pow(10,$Decimals))/pow(10,$Decimals);

                if($DataDescription["Format"]["Y"] == "number") $Value = $Value.$DataDescription["Unit"]["Y"];
                if($DataDescription["Format"]["Y"] == "time") $Value = $this->ToTime($Value);
                if($DataDescription["Format"]["Y"] == "date") $Value = $this->ToDate($Value);
                if($DataDescription["Format"]["Y"] == "metric") $Value = $this->ToMetric($Value,1);
                if($DataDescription["Format"]["Y"] == "kbyte") $Value = $this->ToMetric($Value*1024,1,1024);
                if($DataDescription["Format"]["Y"] == "mbyte") $Value = $this->ToMetric($Value*1024*1024,1,1024);
                if($DataDescription["Format"]["Y"] == "gbyte") $Value = $this->ToMetric($Value*1024*1024*1024,1,1024);
                if($DataDescription["Format"]["Y"] == "currency") $Value = $this->ToCurrency($Value);

                $Position = imageftbbox($this->FontSize,0,$this->FontName,$Value);
                $TextWidth = $Position[2]-$Position[0];
                $TextHeight = $Position[5]-$Position[5]-$Position[5];

                $this->drawFilledRoundedRectangle($this->GArea_X1-13-$TextWidth,$YPos-($this->FontSize/2)-3+10,$TextWidth+7,$this->FontSize+7,7,$this->dS_Y,$this->dS_Y,$this->dS_Y,100);
                imagettftext($this->Picture,$this->FontSize,0,$this->GArea_X1-10-$TextWidth,$YPos+($this->FontSize/2)+10,$C_TextColor,$this->FontName,$Value);
                if($XMin > $this->GArea_X1-10-$TextWidth || $XMin == NULL) $XMin = $this->GArea_X1-10-$TextWidth;

                $YPos = $YPos-$this->DivisionHeight;
            }

            /* Horizontal Axis */
            $XPos = $this->GArea_X1 + $this->GAreaXOffset;
            $ID = 1; $YMax = NULL;
            $YPos = $this->GArea_Y2+25;
            $S_TextColor=$this->AllocateColor($this->Picture,5,5,5);
            foreach($Data as $Key=>$Values) {
                if($ID%$SkipLabels == 0) {
                    //$this->drawLine(floor($XPos),floor($YPos),floor($XPos),floor($YPos)+5,$R,$G,$B);
                    $Value = $Data[$Key][$DataDescription["Position"]];
                    if($DataDescription["Format"]["X"] == "number") $Value = $Value.$DataDescription["Unit"]["X"];
                    if($DataDescription["Format"]["X"] == "time") $Value = $this->ToTime($Value);
                    if($DataDescription["Format"]["X"] == "date") $Value = $this->ToDate($Value);
                    if($DataDescription["Format"]["X"] == "metric") $Value = $this->ToMetric($Value,1);
                    if($DataDescription["Format"]["X"] == "kbyte") $Value = $this->ToMetric($Value*1024,1,1024);
                    if($DataDescription["Format"]["X"] == "mbyte") $Value = $this->ToMetric($Value*1024*1024,1,1024);
                    if($DataDescription["Format"]["X"] == "gbyte") $Value = $this->ToMetric($Value*1024*1024*1024,1,1024);
                    if($DataDescription["Format"]["X"] == "currency") $Value = $this->ToCurrency($Value);

                    $Position = imageftbbox($this->FontSize,$Angle,$this->FontName,$Value);
                    $TextWidth = abs($Position[2])+abs($Position[0]);
                    $TextHeight = abs($Position[1])+abs($Position[3]);

                    if($Angle == 0) {
                        //$YPos = $this->GArea_Y2+18;
                        //imagettftext($this->Picture,$this->FontSize,$Angle,floor($XPos)-floor($TextWidth/2),floor($YPos)+1,$S_TextColor,$this->FontName,$Value);
                        //imagettftext($this->Picture,$this->FontSize,$Angle,floor($XPos)-floor($TextWidth/2),floor($YPos),$C_TextColor,$this->FontName,$Value);
                    } else {
                        $YPos = $this->GArea_Y2+10+$TextHeight;
                        if($Angle <= 90) {
                            //imagettftext($this->Picture,$this->FontSize,$Angle,floor($XPos)-$TextWidth+5,$YPos,$C_TextColor,$this->FontName,$Value);
                        } else {
                            //imagettftext($this->Picture,$this->FontSize,$Angle,floor($XPos)+$TextWidth+5,$YPos,$C_TextColor,$this->FontName,$Value);
                        }
                    }

                    if($YMax < $YPos || $YMax == NULL) $YMax = $YPos;
                }

                $XPos = $XPos+$this->DivisionWidth;
                $ID++;
            }

            /* Write the X Axis caption if set */
            if(isset($DataDescription["Axis"]["X"])) {
                $Position = imageftbbox($this->FontSize,90,$this->FontName,$DataDescription["Axis"]["X"]);
                $TextWidth = abs($Position[2])+abs($Position[0]);
                $TextLeft = (($this->GArea_X2 - $this->GArea_X1) / 2) + $this->GArea_X1 + ($TextWidth/2);
                //imagettftext($this->Picture,$this->FontSize,0,$TextLeft,$YMax+$this->FontSize+5,$C_TextColor,$this->FontName,$DataDescription["Axis"]["X"]);
            }
        }

        /* This function create a filled rectangle with rounded corners and antialias */
        function drawFilledRoundedRectangle($X1,$Y1,$X2,$Y2,$Radius,$R,$G,$B,$Alpha=100,$Line=FALSE) {
            if($R < 0) { $R = 0; } if($R > 255) { $R = 255; }
            if($G < 0) { $G = 0; } if($G > 255) { $G = 255; }
            if($B < 0) { $B = 0; } if($B > 255) { $B = 255; }

            $this->Layers[0] = imagecreatetruecolor($X2,$Y2);
            $C_Rectangle = $this->AllocateColor($this->Layers[0],$R,$G,$B);
            $C_White = $this->AllocateColor($this->Layers[0],255,255,255);
            imagefilledrectangle($this->Layers[0],0,0,$X2,$Y2,$C_White);
            imagecolortransparent($this->Layers[0],$C_White);
            $Step = 90/((3.1418*$Radius)/2);

            for($i=0;$i<=90;$i=$i+$Step) {
                $Xi1 = cos(($i+180)*3.1418/180) * $Radius + 0 + $Radius;
                $Yi1 = sin(($i+180)*3.1418/180) * $Radius + 0 + $Radius;

                $Xi2 = cos(($i-90)*3.1418/180) * $Radius + $X2 - $Radius;
                $Yi2 = sin(($i-90)*3.1418/180) * $Radius + 0 + $Radius;

                $Xi3 = cos(($i)*3.1418/180) * $Radius + $X2 - $Radius;
                $Yi3 = sin(($i)*3.1418/180) * $Radius + $Y2 - $Radius;

                $Xi4 = cos(($i+90)*3.1418/180) * $Radius + 0 + $Radius;
                $Yi4 = sin(($i+90)*3.1418/180) * $Radius + $Y2 - $Radius;

                imageline($this->Layers[0],$Xi1,$Yi1,$Radius,$Yi1,$C_Rectangle);
                if(floor($i)<1) $i_plus = 1; else $i_plus = 0;
                imageline($this->Layers[0],$X2-$Radius,$Yi2,$Xi2+$i_plus,$Yi2,$C_Rectangle);
                imageline($this->Layers[0],$X2-$Radius,$Yi3,$Xi3,$Yi3,$C_Rectangle);
                imageline($this->Layers[0],$Xi4,$Yi4,$Radius,$Yi4,$C_Rectangle);

                if($Line) {
                $this->drawAntialiasPixel($X1+$Xi1,$Y1+$Yi1,$R,$G,$B);
                $this->drawAntialiasPixel($X1+$Xi2,$Y1+$Yi2,$R,$G,$B);
                $this->drawAntialiasPixel($X1+$Xi3,$Y1+$Yi3,$R,$G,$B);
                $this->drawAntialiasPixel($X1+$Xi4,$Y1+$Yi4,$R,$G,$B);
                }
            }

            imagefilledrectangle($this->Layers[0],0,$Radius,$X2,$Y2-$Radius,$C_Rectangle);
            imagefilledrectangle($this->Layers[0],$Radius,0,$X2-$Radius,$Y2,$C_Rectangle);

            imagecopymerge($this->Picture,$this->Layers[0],$X1,$Y1,0,0,$X2,$Y2,$Alpha);
            imagedestroy($this->Layers[0]);

            $X1=$X1-.2;$Y1=$Y1-.2;
            $X2=$X2+.2;$Y2=$Y2+.2;
            if($Line) {
            $this->drawLine($X1+$X2-$Radius,$Y1,$X1+$Radius,$Y1,$R,$G,$B);
            $this->drawLine($X1,$Y1+$Y2-$Radius,$X1,$Y1+$Radius,$R,$G,$B);
            $this->drawLine($X1+$X2-$Radius,$Y1+$Y2,$X1+$Radius,$Y1+$Y2,$R,$G,$B);
            $this->drawLine($X1+$X2,$Y1+$Y2-$Radius,$X1+$X2,$Y1+$Radius,$R,$G,$B);
            }
        }

        /* Compute and draw the scale */
        function drawGrid($LineWidth,$Mosaic=TRUE,$R=220,$G=220,$B=220,$Alpha=100,$SkipLabels=1) {

            /* Draw mosaic */
            if($Mosaic) {
                $LayerWidth  = $this->GArea_X2-$this->GArea_X1;
                $LayerHeight = $this->GArea_Y2-$this->GArea_Y1;

                $this->Layers[0] = imagecreatetruecolor($LayerWidth,$LayerHeight);
                $C_White = $this->AllocateColor($this->Layers[0],255,255,255);
                imagefilledrectangle($this->Layers[0],0,0,$LayerWidth,$LayerHeight,$C_White);
                imagecolortransparent($this->Layers[0],$C_White);
                $C_Rectangle =$this->AllocateColor($this->Layers[0],$R,$G,$B);

                /* Horizontal lines */
                $YPos = $this->GArea_Y2-$this->DivisionHeight;
                for($i=1;$i<=$this->DivisionCount;$i++) {
                    if($YPos>$this->GArea_Y1 && $YPos<$this->GArea_Y2) {
                        $this->drawDottedLine($this->GArea_X1+1,floor($YPos)-1,$this->GArea_X2-1,floor($YPos)-1,$LineWidth,$this->dG_line,$this->dG_line,$this->dG_line);
                        $this->drawDottedLine($this->GArea_X1+1,floor($YPos),$this->GArea_X2-1,floor($YPos),$LineWidth,$this->dG_line_under,$this->dG_line_under,$this->dG_line_under);
                    }

                    $YPos = $YPos - $this->DivisionHeight;
                }

                /* Vertical lines */
                if($this->GAreaXOffset == 0) {
                    $XPos = $this->GArea_X1+$this->DivisionWidth+$this->GAreaXOffset;
                    $ColCount = $this->DataCount-2;
                } else {
                    $XPos = $this->GArea_X1+$this->GAreaXOffset;
                    $ColCount = floor(($this->GArea_X2-$this->GArea_X1)/$this->DivisionWidth);
                }

                for($i=1;$i<=$ColCount;$i++) {
                    if($XPos > $this->GArea_X1 && $XPos < $this->GArea_X2) {
                        //$this->drawDottedLine(floor($XPos),$this->GArea_Y1,floor($XPos),$this->GArea_Y2,$LineWidth,$R,$G,$B);
                    }

                    $XPos = $XPos + $this->DivisionWidth;
                }

                $XPos  = $LayerWidth; //$this->GArea_Y2-1;
                $LastX = $XPos;
                $z = 0;
                $type = 0;

                for($i=0;$i<=$this->nmsValueCount-2-$this->nmsCountMinus;$i++) {
                    $LastX = $XPos;
                    $XPos -= $this->DivisionWidth;

                    if($z >= $SkipLabels) {
                        $z=0;

                        if($type == 0) $type = 1;
                        else $type = 0;
                    }

                     if(!$type) {
                        imagefilledrectangle($this->Layers[0],$XPos+($this->DivisionWidth)-$this->nmsCountDelay,0,$XPos-($LastX-$XPos)+($this->DivisionWidth)-$this->nmsCountDelay,$LayerHeight,$C_Rectangle);
                    }

                    $z++;
                }

                imagecopymerge($this->Picture,$this->Layers[0],$this->GArea_X1,$this->GArea_Y1,0,0,$LayerWidth,$LayerHeight,$Alpha);
                imagedestroy($this->Layers[0]);
            }
        }

        /* This function put a label on a specific point */
        function setLabel($Data,$DataDescription,$SerieName,$ValueName,$Caption,$R=210,$G=210,$B=210,$ShadowFactor=255) {

            /* Validate the Data and DataDescription array */
            $this->validateDataDescription("setLabel",$DataDescription);
            $this->validateData("setLabel",$Data);

            $C_Label = $this->AllocateColor($this->Picture,$R,$G,$B);
            $C_Shadow = $this->AllocateColor($this->Picture,$R-$ShadowFactor,$G-$ShadowFactor,$B-$ShadowFactor);
            $C_TextColor = $this->AllocateColor($this->Picture,70,70,70);

            $Cp = 0;
            $Found = FALSE;
            $t=0;

            foreach($Data as $Key=>$Value) {
                if($Data[$Key]["Name"] == $ValueName) {
                    $NumericalValue = $Data[$Key][$SerieName];
                    $Found = TRUE;
                }

                if (!$Found) $Cp++;
            }

            $Position   = imageftbbox($this->FontSize,0,$this->FontName,$Caption);
            $TextHeight = $Position[3] - $Position[5]+20;
            $TextWidth  = $Position[2]-$Position[0] + 2 +10;
            $TextOffset = floor($TextHeight/2);

            $XPos = $this->GArea_X1+$this->GAreaXOffset+($this->DivisionWidth*$Cp)+2;
            $YPos = $this->GArea_Y2-($NumericalValue-$this->VMin)*$this->DivisionRatio;

            $XPos2 = (($this->GArea_X2/100)*60) - $this->nmsLabelLeft - $TextWidth;
            $YPos2 = 40 + $this->nmsLabelTop/2;

            $this->drawDottedLine($XPos-2,$YPos,$XPos2+5+$TextWidth,$YPos2+$TextOffset-13,3,100,100,100);
            $this->drawFilledRoundedRectangle($XPos2,$YPos2-9,$TextWidth+15,20,10,$ShadowFactor,$ShadowFactor,$ShadowFactor,30);
            $this->drawFilledCircle($XPos-1,$YPos+1,2,$R,$G,$B);
            $this->drawFilledCircle($XPos2+5+$TextWidth,$YPos2+$TextOffset-13,2,$R-50,$G-50,$B-50);
            imagettftext($this->Picture,$this->FontSize,0,$XPos2+10,$YPos2 + $TextOffset-10,$C_TextColor,$this->FontName,$Caption);
            $this->nmsLabelLeft += $TextWidth + floor($this->GArea_X2/100*3);
            $this->nmsLabelTop += 25;
        }

        /* This function put a label on a specific point */
        function setLabelDelay($Data,$DataDescription,$SerieName,$ValueName,$Caption,$R=210,$G=210,$B=210,$ShadowFactor=5,$time=FALSE) {

            /* Validate the Data and DataDescription array */
            $this->validateDataDescription("setLabel",$DataDescription);
            $this->validateData("setLabel",$Data);

            $C_Label = $this->AllocateColor($this->Picture,$R,$G,$B);
            $C_Shadow = $this->AllocateColor($this->Picture,$R-$ShadowFactor,$G-$ShadowFactor,$B-$ShadowFactor);
            $C_TextColor = $this->AllocateColor($this->Picture,150,150,150);

            $Cp = 0;
            $Found = FALSE;
            $t=0;

            foreach($Data as $Key=>$Value) {
                if($Data[$Key]["Name"] == $ValueName) {
                    $NumericalValue = $Data[$Key][$SerieName];
                    $Found = TRUE;
                }

                if (!$Found) $Cp++;
            }

            $Position   = imageftbbox($this->FontSize,0,$this->FontName,$Caption);
            $TextHeight = $Position[3] - $Position[5]+20;
            $TextWidth  = $Position[2]-$Position[0] + 2 +10;
            $TextOffset = floor($TextHeight/2);

            $XPos = $this->GArea_X1+$this->GAreaXOffset+($this->DivisionWidth*$Cp)+2;
            $YPos = $this->GArea_Y2-($NumericalValue-$this->VMin)*$this->DivisionRatio;

            $this->drawDottedLine(floor($XPos),floor($this->GArea_Y1-8),floor($XPos),floor($this->GArea_Y2),1,$R-$ShadowFactor,$G-$ShadowFactor,$B-$ShadowFactor);

            if($time) {
                $this->drawFilledRoundedRectangle(floor($XPos-6),floor(($this->GArea_Y2/2)-$TextWidth/2+($this->GArea_Y1/2)),13,$TextWidth-4,7,$R-$ShadowFactor,$G-$ShadowFactor,$B-$ShadowFactor,70);

                $this->drawTextBox(floor($XPos-3),floor($this->GArea_Y2/2-($TextWidth/2)+22),12,$TextWidth,$Caption,270,$this->LabelDelayName,$this->LabelDelayName,$this->LabelDelayName,null,FALSE);
            }
        }

        /* Draw a text box with text align & alpha properties */
        function drawTextBox($X1,$Y1,$X2,$Y2,$Text,$Angle=0,$R=255,$G=255,$B=255,$Align=ALIGN_LEFT,$Shadow=TRUE,$Box=FALSE,$Alpha=100,$Type=FALSE,$Line=FALSE) {
            $Position = imageftbbox($this->FontSize,$Angle,$this->FontName,$Text);
            $TextWidth = $Position[2]-$Position[0];
            $TextHeight = $Position[5]-$Position[3];
            $AreaWidth = $X2 - $X1;
            $AreaHeight = $Y2 - $Y1;
            $R_ShadowFactor = $this->R_ShadowFactor;
            $G_ShadowFactor = $this->G_ShadowFactor;
            $B_ShadowFactor = $this->B_ShadowFactor;
            if($Type) $R_ShadowFactor += 45;

            if($Align == ALIGN_TOP_LEFT) { $X = $X1+1; $Y = $Y1+$this->FontSize+1; }
            if($Align == ALIGN_TOP_CENTER) { $X = $X1+($AreaWidth/2)-($TextWidth/2); $Y = $Y1+$this->FontSize+1; }
            if($Align == ALIGN_TOP_RIGHT) { $X = $X2-$TextWidth-1-5; $Y = $Y1+$this->FontSize+1; }
            if($Align == ALIGN_LEFT) { $X = $X1+1; $Y = $Y1+($AreaHeight/2)-($TextHeight/2); }
            if($Align == ALIGN_CENTER) { $X = $X1+($AreaWidth/2)-($TextWidth/2); $Y = $Y1+($AreaHeight/2)-($TextHeight/2); }
            if($Align == ALIGN_RIGHT) { $X = $X2-$TextWidth-1; $Y = $Y1+($AreaHeight/2)-($TextHeight/2); }
            if($Align == ALIGN_BOTTOM_LEFT) { $X = $X1+1; $Y = $Y2-1; }
            if($Align == ALIGN_BOTTOM_CENTER) { $X = $X1+($AreaWidth/2)-($TextWidth/2); $Y = $Y2-1; }
            if($Align == ALIGN_BOTTOM_RIGHT) { $X = $X2-$TextWidth-1; $Y = $Y2-1; }
            if($Align == null) { $X = $X1; $Y = $Y1; }

            $C_TextColor = $this->AllocateColor($this->Picture,$R,$G,$B);
            $C_ShadowColor = $this->AllocateColor($this->Picture,70,70,70);

            if($Box) $this->drawFilledRoundedRectangle($X-5,$Y-$this->FontSize*2+4,$TextWidth+10,$this->FontSize*2,7,$R_ShadowFactor,$G_ShadowFactor,$B_ShadowFactor,$Alpha,$Line);
            if($Shadow) imagettftext($this->Picture,$this->FontSize,$Angle,$X+1,$Y+1,$C_ShadowColor,$this->FontName,$Text);
            imagettftext($this->Picture,$this->FontSize,$Angle,$X,$Y,$C_TextColor,$this->FontName,$Text);
        }
    }
?>